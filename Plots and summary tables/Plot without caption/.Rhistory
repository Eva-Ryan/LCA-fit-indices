# generate r random seeds
set.seed(123)
r_seeds <- sample.int(1000000000, size = r, replace = FALSE)
# set number of classes and number of items
num_classes <- ncol(rhos)
num_items <- nrow(rhos)
# simulate r datasets and store in the list datasets_list
datasets_list <- list()
for(i in 1:r){
# initialise data matrix
df <- matrix(NA, nrow = N, ncol = num_items + 1) # extra column for class
# assign classes and populate first column of data matrix with class number
set.seed(r_seeds[i])
df[,1] <- sample(c(1:num_classes, N, replace = TRUE, prob = gammas))
# simulate class dependent item responses k for class j
for(j in 1:num_classes){
# create vector of indices for the cases which are in class j
ind <- which(df[,1] == j, arr.ind = TRUE)
# create an empty matrix to store the item responses for the class j cases
sim.vals <- matrix(NA, length(ind), num_items)
# loop through the k items and generate responses
for(k in 1:num_items){
# set a new seed for each item/class/replication
set.seed( round(r_seeds[i]/(j * k * 1000), 0) )
sim.vals[,k] <- sample(c(1,0), length(ind), replace = TRUE,
prob = c(rhos[k,j], 1 - rhos[k,j]))
}
# populate the rows of the data matrix that correspond to class j with
# the generated item responses
df[ind, 2:num_items+1] <- sim.vals
}
# save as dataframe and convert column entries to type factor
df <- as.data.frame(df)
df[] <- lapply(df, factor)
# save generated dataset in list
datasets_list[[i]] <- df
}
# create list of outputs
ret <- list()
ret$datasets <- datasets_list
ret$rhos <- rhos
ret$gammas <- gammas
ret$N <- N
ret$r <- r
ret$seeds <- r_seeds
return(ret)
}
## set input parameters for LCA_sim
# sample size
N = 5000
# number of replications
r = 1000
# create matrix of item response probabilities
rhos <- matrix(.8, nrow = 6, ncol = 5)
rhos[3:6,1] <- .2
rhos[5:6,2] <- .2
rhos[c(2,4,6),4] <- .2
rhos[c(1,4),5] <- .9
rhos[2:3,5] <- .7
rhos[5,5] <- .3
rhos[6,5] <- .1
# create vector of class membership probabilities
gammas <- c(0.3, 0.25, 0.15, 0.15, 0.15)
## simulate data sets
sims <- LCA_sim(N, r, rhos, gammas)
set.seed(123)
r_seeds <- sample.int(1000000000, size = r, replace = FALSE)
# set number of classes and number of items
num_classes <- ncol(rhos)
num_items <- nrow(rhos)
df <- matrix(NA, nrow = N, ncol = num_items + 1)
set.seed(r_seeds[i])
set.seed(r_seeds[1])
df[,1] <- sample(c(1:num_classes, N, replace = TRUE, prob = gammas))
set.seed(r_seeds[1]sample(c(1:num_classes, N, replace = TRUE, prob = gammas))
sample(c(1:num_classes, N, replace = TRUE, prob = gammas))
sample(1:num_classes, N, replace = TRUE, prob = gammas))
sample(1:num_classes, N, replace = TRUE, prob = gammas)
################################################################################
# Use this script to generate datasets for the simulation study prior to running
# the code in 2.Fit models in LatentGOLD.R to fit LCA models to the generated
# datasets.
################################################################################
## create function LCA_sim to generate data
LCA_sim <- function(N, r, rhos, gammas){
# Inputs: N = sample size for each generated dataset
#         r = replications - number of datasets to generate
#         rhos = matrix of item response probabilities
#         gammas = vector of class membership probabilities
# Outputs: a list ret containing the values for all input parameters, an
#          array datasets containing the generated datasets, and a vector
#          seeds containing the seeds used to ensure the data generation
#          is reproducible
# generate r random seeds
set.seed(123)
r_seeds <- sample.int(1000000000, size = r, replace = FALSE)
# set number of classes and number of items
num_classes <- ncol(rhos)
num_items <- nrow(rhos)
# simulate r datasets and store in the list datasets_list
datasets_list <- list()
for(i in 1:r){
# initialise data matrix
df <- matrix(NA, nrow = N, ncol = num_items + 1) # extra column for class
# assign classes and populate first column of data matrix with class number
set.seed(r_seeds[i])
df[,1] <- sample(1:num_classes, N, replace = TRUE, prob = gammas)
# simulate class dependent item responses k for class j
for(j in 1:num_classes){
# create vector of indices for the cases which are in class j
ind <- which(df[,1] == j, arr.ind = TRUE)
# create an empty matrix to store the item responses for the class j cases
sim.vals <- matrix(NA, length(ind), num_items)
# loop through the k items and generate responses
for(k in 1:num_items){
# set a new seed for each item/class/replication
set.seed( round(r_seeds[i]/(j * k * 1000), 0) )
sim.vals[,k] <- sample(c(1,0), length(ind), replace = TRUE,
prob = c(rhos[k,j], 1 - rhos[k,j]))
}
# populate the rows of the data matrix that correspond to class j with
# the generated item responses
df[ind, 2:num_items+1] <- sim.vals
}
# save as dataframe and convert column entries to type factor
df <- as.data.frame(df)
df[] <- lapply(df, factor)
# save generated dataset in list
datasets_list[[i]] <- df
}
# create list of outputs
ret <- list()
ret$datasets <- datasets_list
ret$rhos <- rhos
ret$gammas <- gammas
ret$N <- N
ret$r <- r
ret$seeds <- r_seeds
return(ret)
}
## set input parameters for LCA_sim
# sample size
N = 5000
# number of replications
r = 1000
# create matrix of item response probabilities
rhos <- matrix(.8, nrow = 6, ncol = 5)
rhos[3:6,1] <- .2
rhos[5:6,2] <- .2
rhos[c(2,4,6),4] <- .2
rhos[c(1,4),5] <- .9
rhos[2:3,5] <- .7
rhos[5,5] <- .3
rhos[6,5] <- .1
# create vector of class membership probabilities
gammas <- c(0.3, 0.25, 0.15, 0.15, 0.15)
## simulate data sets
sims <- LCA_sim(N, r, rhos, gammas)
df <- matrix(NA, nrow = N, ncol = num_items + 1) # extra column for class
# assign classes and populate first column of data matrix with class number
set.seed(r_seeds[1])
df[,1] <- sample(1:num_classes, N, replace = TRUE, prob = gammas)
head(df)
ind <- which(df[,1] == 1, arr.ind = TRUE)
sim.vals <- matrix(NA, length(ind), num_items)
sim.vals[,1] <- sample(c(1,0), length(ind), replace = TRUE,
prob = c(rhos[1,1], 1 - rhos[1,1]))
2:num_items+1
2:(num_items+1)
################################################################################
# Use this script to generate datasets for the simulation study prior to running
# the code in 2.Fit models in LatentGOLD.R to fit LCA models to the generated
# datasets.
################################################################################
## create function LCA_sim to generate data
LCA_sim <- function(N, r, rhos, gammas){
# Inputs: N = sample size for each generated dataset
#         r = replications - number of datasets to generate
#         rhos = matrix of item response probabilities
#         gammas = vector of class membership probabilities
# Outputs: a list ret containing the values for all input parameters, an
#          array datasets containing the generated datasets, and a vector
#          seeds containing the seeds used to ensure the data generation
#          is reproducible
# generate r random seeds
set.seed(123)
r_seeds <- sample.int(1000000000, size = r, replace = FALSE)
# set number of classes and number of items
num_classes <- ncol(rhos)
num_items <- nrow(rhos)
# simulate r datasets and store in the list datasets_list
datasets_list <- list()
for(i in 1:r){
# initialise data matrix
df <- matrix(NA, nrow = N, ncol = (num_items + 1)) # extra column for class
# assign classes and populate first column of data matrix with class number
set.seed(r_seeds[i])
df[,1] <- sample(1:num_classes, N, replace = TRUE, prob = gammas)
# simulate class dependent item responses k for class j
for(j in 1:num_classes){
# create vector of indices for the cases which are in class j
ind <- which(df[,1] == j, arr.ind = TRUE)
# create an empty matrix to store the item responses for the class j cases
sim.vals <- matrix(NA, length(ind), num_items)
# loop through the k items and generate responses
for(k in 1:num_items){
# set a new seed for each item/class/replication
set.seed( round(r_seeds[i]/(j * k * 1000), 0) )
sim.vals[,k] <- sample(c(1,0), length(ind), replace = TRUE,
prob = c(rhos[k,j], 1 - rhos[k,j]))
}
# populate the rows of the data matrix that correspond to class j with
# the generated item responses
df[ind, 2:(num_items+1)] <- sim.vals
}
# save as dataframe and convert column entries to type factor
df <- as.data.frame(df)
df[] <- lapply(df, factor)
# save generated dataset in list
datasets_list[[i]] <- df
}
# create list of outputs
ret <- list()
ret$datasets <- datasets_list
ret$rhos <- rhos
ret$gammas <- gammas
ret$N <- N
ret$r <- r
ret$seeds <- r_seeds
return(ret)
}
## set input parameters for LCA_sim
# sample size
N = 5000
# number of replications
r = 1000
# create matrix of item response probabilities
rhos <- matrix(.8, nrow = 6, ncol = 5)
rhos[3:6,1] <- .2
rhos[5:6,2] <- .2
rhos[c(2,4,6),4] <- .2
rhos[c(1,4),5] <- .9
rhos[2:3,5] <- .7
rhos[5,5] <- .3
rhos[6,5] <- .1
# create vector of class membership probabilities
gammas <- c(0.3, 0.25, 0.15, 0.15, 0.15)
## simulate data sets
sims <- LCA_sim(N, r, rhos, gammas)
sims$rhos
sims$N
sims$r
sims$seeds
head(sims$datasets[i])
head(sims$datasets[1])
head(sims$datasets[[1]])
head(sims$datasets[[2]])
names(df) <- c("Class", apply(1:num_items, f(x){paste0("V", x)}))
?apply
names(df) <- c("Class", apply(1:num_items, function(x) paste0("V", x)))
names(df) <- c("Class", apply(1:num_items, FUN = function(x) paste0("V", x)))
i:num_items
1:num_items
apply(X = 1:num_items, MARGIN = 2, FUN = function(x) paste0("V", x))
c("Class", paste0("V", 1:num_items))
################################################################################
# Use this script to generate datasets for the simulation study prior to running
# the code in "2 Fit models in LatentGOLD.R" to fit LCA models to the generated
# datasets.
################################################################################
## function to generate data
LCA_sim <- function(N, r, rhos, gammas){
# Inputs: N = sample size for each generated dataset
#         r = replications - number of datasets to generate
#         rhos = matrix of item response probabilities
#         gammas = vector of class membership probabilities
# Outputs: a list ret containing the values for all input parameters, an
#          array datasets containing the generated datasets, and a vector
#          seeds containing the seeds used to ensure the data generation
#          is reproducible
# generate r random seeds
set.seed(123)
r_seeds <- sample.int(1000000000, size = r, replace = FALSE)
# set number of classes and number of items
num_classes <- ncol(rhos)
num_items <- nrow(rhos)
# simulate r datasets and store in the list datasets_list
datasets_list <- list()
for(i in 1:r){
# initialise data matrix
df <- matrix(NA, nrow = N, ncol = (num_items + 1)) # extra column for class
# assign classes and populate first column of data matrix with class number
set.seed(r_seeds[i])
df[,1] <- sample(1:num_classes, N, replace = TRUE, prob = gammas)
# simulate class dependent item responses k for class j
for(j in 1:num_classes){
# create vector of indices for the cases which are in class j
ind <- which(df[,1] == j, arr.ind = TRUE)
# create an empty matrix to store the item responses for the class j cases
sim.vals <- matrix(NA, length(ind), num_items)
# loop through the k items and generate responses
for(k in 1:num_items){
# set a new seed for each item/class/replication
set.seed( round(r_seeds[i]/(j * k * 1000), 0) )
sim.vals[,k] <- sample(c(1,0), length(ind), replace = TRUE,
prob = c(rhos[k,j], 1 - rhos[k,j]))
}
# populate the rows of the data matrix that correspond to class j with
# the generated item responses
df[ind, 2:(num_items+1)] <- sim.vals
}
# save as dataframe, name columns, and convert column entries to type factor
df <- as.data.frame(df)
names(df) <- c("Class", paste0("V", 1:num_items))
df[] <- lapply(df, factor)
# save generated dataset in list
datasets_list[[i]] <- df
}
# create list of outputs
ret <- list()
ret$datasets <- datasets_list
ret$rhos <- rhos
ret$gammas <- gammas
ret$N <- N
ret$r <- r
ret$seeds <- r_seeds
return(ret)
}
## set input parameters for LCA_sim
# sample size
N = 500
# number of replications
r = 1000
# create matrix of item response probabilities
rhos <- matrix(.8, nrow = 6, ncol = 5)
rhos[3:6,1] <- .2
rhos[5:6,2] <- .2
rhos[c(2,4,6),4] <- .2
rhos[c(1,4),5] <- .9
rhos[2:3,5] <- .7
rhos[5,5] <- .3
rhos[6,5] <- .1
# create vector of class membership probabilities
gammas <- c(0.3, 0.25, 0.15, 0.15, 0.15)
## simulate data sets
# time data generation
library(tictoc)
tic("Data generation runtime")
# generate data
sims <- LCA_sim(N, r, rhos, gammas)
# finish timing
toc()
library(tidyverse)
library(gridExtra)
library(grid)
library(ggpubr)
## function to calculate means and 95% coverage intervals for each stat and
# construct plots
plot_means_CI <- function(file_names, max_class, N){
# Inputs: file_names = naming convention for the folders/files relating to the
#                      simulation of interest
#         max_class = the maximum number of classes in the models fitted to
#                     the simulated datasets
#         N = sample size for the simulations
# Output: plot_list = list containing the AIC/BIC/NFI plots
# set working directory to where fit index summaries are saved
setwd("C:/Users/eva.ryan/Desktop/Year 3 Semester 2/Thesis work/LCA fit indices/Final simulations/R/Final output summaries")
# read in summary of simulation models fit stats
df <- read_csv(paste0(file_names, "_output_summary.csv"))
# create empty dataframes to populate with means and confidence intervals for
# each fit stat
# AIC
AICs <- as.data.frame(matrix(NA, nrow = max_class, ncol =  4))
names(AICs) <- c("classes", "means", "lower", "upper")
AICs$classes <- 1:max_class
# BIC
BICs <- as.data.frame(matrix(NA, nrow = max_class, ncol =  4))
names(BICs) <- c("classes", "means", "lower", "upper")
BICs$classes <- 1:max_class
# NFI
NFIs <- as.data.frame(matrix(NA, nrow = max_class, ncol =  4))
names(NFIs) <- c("classes", "means", "lower", "upper")
NFIs$classes <- 1:max_class
# cycle through different number of classes
for(c in 1:max_class){
# filter out just models with c classes
df_c <- df %>%
filter(Number_of_classes == c)
# calculate mean and 95% coverage intervals
# AIC
AICs$means[c] <- mean(df_c$AIC)
AICs$lower[c] <- df_c$AIC[order(df_c$AIC)][25]
AICs$upper[c] <- df_c$AIC[order(df_c$AIC)][976]
# BIC
BICs$means[c] <- mean(df_c$BIC)
BICs$lower[c] <- df_c$BIC[order(df_c$BIC)][25]
BICs$upper[c] <- df_c$BIC[order(df_c$BIC)][976]
# NFI
NFIs$means[c] <- mean(df_c$NFI)
NFIs$lower[c] <- df_c$NFI[order(df_c$NFI)][25]
NFIs$upper[c] <- df_c$NFI[order(df_c$NFI)][976]
}
## create plots
# AIC plot
aic_plot <- ggplot(AICs, aes(x = classes, y = means)) +
geom_line(linewidth = 1) +
geom_errorbar(linewidth = 1, width = .75, aes(ymin = lower, ymax = upper),
colour = "red") +
geom_point(shape = 21, size = 2, fill = "white") +
theme_light() +
xlab("") + ylab("") +
ggtitle("AIC") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(breaks = c(1:max_class))
# BIC plot
bic_plot <- ggplot(BICs, aes(x = classes, y = means)) +
geom_line(linewidth = 1) +
geom_errorbar(linewidth = 1, width = .75, aes(ymin = lower, ymax = upper),
colour = "red") +
geom_point(shape = 21, size = 2, fill = "white") +
theme_light() +
xlab("") + ylab("") +
ggtitle("BIC") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(breaks = c(1:max_class))
# NFI plot
nfi_plot <- ggplot(NFIs, aes(x = classes, y = means)) +
geom_line(linewidth = 1) +
geom_errorbar(linewidth = 1, width = .75, aes(ymin = lower, ymax = upper),
colour = "red") +
geom_point(shape = 21, size = 2, fill = "white") +
theme_light() +
xlab("") + ylab("") +
ggtitle("NFI") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(breaks = c(1:max_class))
## save plots individually
# set working directory to plots folder
# setwd("C:/Users/eva.ryan/Desktop/Year 3 Semester 2/Thesis work/LCA fit indices/Final simulations/R/Plots and summary tables")
#
# # AIC
# ggsave(
#   filename = paste0(file_names, "_AIC_plot.jpg"),
#   plot = aic_plot,
#   units = "in",
#   width = 7,
#   height = 5,
#   dpi = 600
# )
# # BIC
# ggsave(
#   filename = paste0(file_names, "_BIC_plot.jpg"),
#   plot = bic_plot,
#   units = "in",
#   width = 7,
#   height = 5,
#   dpi = 600
# )
# # NFI
# ggsave(
#   filename = paste0(file_names, "_NFI_plot.jpg"),
#   plot = nfi_plot,
#   units = "in",
#   width = 7,
#   height = 5,
#   dpi = 600
# )
# return list of plots
plot_list <- list()
plot_list[[1]] <- aic_plot
plot_list[[2]] <- bic_plot
plot_list[[3]] <- nfi_plot
return(plot_list)
}
## create individual plots for different sample sizes
plots_500 <- plot_means_CI(file_names = paste0("sims_", 500),
max_class = 6,
N = 500)
#plots_1000 <- plot_means_CI(file_names = paste0("sims_", 1000),
#                           max_class = 6,
#                           N = 1000)
plots_5000 <- plot_means_CI(file_names = paste0("sims_", 5000),
max_class = 6,
N = 5000)
plots_10000 <- plot_means_CI(file_names = paste0("sims_", 10000),
max_class = 6,
N = 10000)
plots_30000 <- plot_means_CI(file_names = paste0("sims_", 30000),
max_class = 6,
N = 30000)
plots_100000 <- plot_means_CI(file_names = paste0("sims_", 100000),
max_class = 6,
N = 100000)
## combine all plots together into one figure
plot_grid <- grid.arrange(
arrangeGrob(grobs = plots_500, left = "N = 500", ncol = 3, nrow = 1),
#arrangeGrob(grobs = plots_1000, left = "N = 1,000", ncol = 3, nrow = 1),
arrangeGrob(grobs = plots_5000, left = "N = 5,000", ncol = 3, nrow = 1),
arrangeGrob(grobs = plots_10000, left = "N = 10,000", ncol = 3, nrow = 1),
arrangeGrob(grobs = plots_30000, left = "N = 30,000", ncol = 3, nrow = 1),
arrangeGrob(grobs = plots_100000, left = "N = 100,000", ncol = 3, nrow = 1),
ncol = 1, nrow = 5)#,
setwd("C:/Users/eva.ryan/Desktop/Year 3 Semester 2/Thesis work/LCA fit indices/Final simulations/R/Plots and summary tables/Plot without caption")
# save the combined plot
ggsave(
filename = "All_plots.jpg",
plot = plot_grid,
units = "in",
width = 10,
height = 15,
dpi = 1000
)
